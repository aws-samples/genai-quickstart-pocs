"""
GenerateServiceProfile Lambda Function
Generates Security Research Profiles using IAM models and service documentation
"""
import json
import boto3
import os
import logging
from datetime import datetime
from bedrock_client import get_bedrock_client
from dynamodb_operations import (
    get_service_actions_from_dynamodb,
    get_service_parameters_from_dynamodb,
    get_service_data_with_parent_support
)
from s3_operations import store_output_in_s3
from validation import validate_input
from json_processing import extract_json_from_content, convert_json_to_markdown

# Set up logging
logger = logging.getLogger()
logger.setLevel(logging.INFO)

# Environment variables
SERVICE_ACTIONS_TABLE = os.environ.get('DYNAMODB_TABLE_SERVICE_ACTIONS', 'gensec-AWSServiceActions')
SERVICE_PARAMETERS_TABLE = os.environ.get('DYNAMODB_TABLE_SERVICE_PARAMETERS', 'gensec-AWSServiceParameters')
OUTPUT_BUCKET = os.environ.get('S3_OUTPUT_BUCKET', os.environ.get('S3_DOCUMENTATION_BUCKET'))
INPUT_BUCKET = os.environ.get('S3_INPUT_BUCKET')

# Initialize Bedrock client
bedrock_client = get_bedrock_client('claude-4')

# Initialize S3 client
s3_client = boto3.client('s3')

# No longer needed - using centralized functions from DynamoDB layer

# Initialize S3 client
s3_client = boto3.client('s3')

def load_iam_model_outputs(service_id):
    """Load IAM model outputs from S3"""
    try:
        logger.info(f"Loading IAM model outputs from S3 for {service_id}")
        
        # Load iam_model.json
        iam_model_key = f"{service_id}/iam-models/iam_model.json"
        iam_model_response = s3_client.get_object(Bucket=OUTPUT_BUCKET, Key=iam_model_key)
        iam_model = json.loads(iam_model_response['Body'].read().decode('utf-8'))
        logger.info(f"Loaded IAM model with {len(iam_model.get('actions', []))} actions")
        
        # Load business_use_cases.json
        business_key = f"{service_id}/iam-models/business_use_cases.json"
        business_response = s3_client.get_object(Bucket=OUTPUT_BUCKET, Key=business_key)
        business_use_cases = json.loads(business_response['Body'].read().decode('utf-8'))
        logger.info(f"Loaded business use cases with {len(business_use_cases.get('use_cases', []))} personas")
        
        return iam_model, business_use_cases
        
    except s3_client.exceptions.NoSuchKey as e:
        logger.error(f"IAM model outputs not found in S3: {str(e)}")
        raise ValueError(f"IAM model outputs must be generated before Security Research Profile. Missing: {str(e)}")
    except Exception as e:
        logger.error(f"Error loading IAM model outputs: {str(e)}")
        raise

def generate_service_profile(input_data):
    """Generate both original service profile AND Security Research Profile"""
    try:
        logger.info("Starting dual profile generation (service profile + security research profile)")
        
        # Extract required input data
        service_id = input_data.get('serviceId')
        if not service_id:
            raise ValueError("serviceId is required in input")
        
        # Normalize service_id to lowercase
        service_id_normalized = service_id.lower()
        logger.info(f"Processing service_id: {service_id} (normalized: {service_id_normalized})")
        
        # Load IAM model outputs from S3 (generated by GenerateIAMModel)
        iam_model, business_use_cases = load_iam_model_outputs(service_id_normalized)
        
        # Query DynamoDB for raw service documentation, handling parent services
        validated_actions, validated_parameters = get_service_data_with_parent_support(
            service_id, SERVICE_ACTIONS_TABLE, SERVICE_PARAMETERS_TABLE, INPUT_BUCKET
        )
        
        if not validated_actions:
            raise ValueError("No validated actions found in service documentation")
        
        # Map service ID to full name
        service_name = get_service_full_name(service_id_normalized)
        logger.info(f"Generating profiles for: {service_name}")
        
        # ========================================================================
        # PART 1: Generate Original Service Profile (JSON)
        # ========================================================================
        logger.info("Generating original service profile (JSON)")
        
        service_profile_prompt = create_service_profile_prompt(
            service_name,
            validated_parameters,
            validated_actions
        )
        
        service_profile_response = bedrock_client.invoke(service_profile_prompt)
        
        if service_profile_response:
            # Parse JSON response
            profile_json = extract_json_from_content(service_profile_response)
            if profile_json:
                # Generate markdown version
                profile_markdown = convert_json_to_markdown(profile_json, f"{service_name} Service Profile")
                
                # Store both versions
                store_service_profile_outputs(service_id_normalized, profile_json, profile_markdown)
                logger.info("✓ Original service profile generated")
            else:
                logger.warning("Failed to parse service profile JSON, skipping original profile")
        else:
            logger.warning("Failed to generate service profile, skipping original profile")
        
        # ========================================================================
        # PART 2: Generate Security Research Profile (Markdown)
        # ========================================================================
        logger.info("Generating Security Research Profile (Markdown)")
        
        security_profile_prompt = create_security_research_profile_prompt(
            service_name,
            iam_model,
            business_use_cases,
            validated_actions,
            validated_parameters
        )
        
        security_profile_response = bedrock_client.invoke(security_profile_prompt)
        
        if not security_profile_response:
            raise ValueError("Failed to generate Security Research Profile")
        
        # Store markdown output
        markdown_content = security_profile_response.strip()
        store_security_research_profile(service_id_normalized, markdown_content)
        logger.info("✓ Security Research Profile generated")
        
        return {
            "statusCode": 200,
            "body": {
                "serviceId": service_id_normalized,
                "serviceName": service_name,
                "outputs": {
                    "service_profile_json": f"{service_id_normalized}/service-profiles/profile.json",
                    "service_profile_md": f"{service_id_normalized}/service-profiles/profile.md",
                    "security_research_profile": f"{service_id_normalized}/service-profiles/security_research_profile.md"
                },
                "metadata": {
                    "actions_count": len(validated_actions),
                    "parameters_count": len(validated_parameters),
                    "personas_count": len(business_use_cases.get('use_cases', [])),
                    "generation_timestamp": datetime.utcnow().isoformat()
                }
            }
        }
        
    except ValueError as ve:
        logger.error(f"Validation error: {str(ve)}")
        raise ve
    except Exception as e:
        logger.error(f"Error generating profiles: {str(e)}")
        raise e

def create_service_profile_prompt(service_name, validated_parameters, validated_actions):
    """Create prompt for original service profile (JSON format)"""
    try:
        # Format validated parameters and actions
        param_capabilities = "\n".join([
            f"- {param['parameter_name']}: {param['description']} (Type: {param['type']})"
            for param in validated_parameters[:30]  # Limit to prevent token overflow
        ])
        
        action_capabilities = "\n".join([
            f"- {action['action_name']}: {action['description']} (Level: {action['accessLevel']})"
            for action in validated_actions[:30]  # Limit to prevent token overflow
        ])
        
        return {
            "prompt": f"""Generate a comprehensive service profile for AWS {service_name} based on these validated capabilities:

Validated Parameters:
{param_capabilities}

Validated Actions:
{action_capabilities}

CRITICAL INSTRUCTIONS:
- Return ONLY the JSON object below
- Do NOT include markdown formatting (no ```json or ```)
- Do NOT include any explanatory text before or after
- Use \\n for line breaks in code strings
- Ensure all quotes are properly escaped

IMPORTANT:
1. Base the profile ONLY on these validated capabilities
2. Do NOT include capabilities not supported by the parameters/actions
3. Ensure all features mentioned are backed by documented parameters or actions
4. Be precise about supported functionality

{{
    "serviceName": "{service_name}",
    "serviceDescription": {{
        "overview": "description based on validated capabilities",
        "serviceType": "type of service",
        "documentation": "AWS documentation link"
    }},
    "dataProtection": {{
        "dataHandling": {{
            "processesCustomerData": true/false,
            "storesCustomerData": true/false,
            "explanation": "based on validated parameters"
        }},
        "encryption": {{
            "atRest": {{
                "supported": true/false,
                "methods": ["only validated encryption methods"],
                "details": "based on validated parameters"
            }},
            "inTransit": {{
                "supported": true/false,
                "methods": ["only validated protocols"],
                "details": "based on validated parameters"
            }}
        }}
    }},
    "networkControls": {{
        "endpoints": ["only validated endpoints"],
        "vpcSupport": true/false,
        "publicExposure": {{
            "required": true/false,
            "details": "based on validated configuration options"
        }}
    }},
    "accessControls": {{
        "iamSupport": {{
            "serviceRoles": ["only validated roles"],
            "managedPolicies": ["only validated policies"]
        }},
        "bestPractices": ["based on validated parameters and actions"]
    }},
    "isolationControls": ["only validated isolation features"],
    "managementOps": {{
        "logging": {{
            "cloudwatchSupport": true/false,
            "cloudtrailSupport": true/false,
            "details": "based on validated logging capabilities"
        }},
        "monitoring": {{
            "metrics": ["only validated metrics"],
            "details": "based on validated monitoring capabilities"
        }}
    }},
    "compliance": {{
        "certifications": ["relevant certifications"],
        "details": "compliance details based on validated features"
    }}
}}

Return the JSON object starting with {{ and ending with }}. Nothing else."""
        }
    except Exception as e:
        logger.error(f"Error creating service profile prompt: {str(e)}")
        raise e

def store_service_profile_outputs(service_id, profile_json, markdown_content):
    """Store original service profile outputs (JSON and Markdown)"""
    try:
        # Store JSON version
        s3_client.put_object(
            Bucket=OUTPUT_BUCKET,
            Key=f"{service_id}/service-profiles/profile.json",
            Body=json.dumps(profile_json, indent=2),
            ContentType='application/json',
            Metadata={
                "document_type": "service_profile",
                "generation_date": datetime.utcnow().isoformat()
            }
        )
        
        # Store markdown version
        s3_client.put_object(
            Bucket=OUTPUT_BUCKET,
            Key=f"{service_id}/service-profiles/profile.md",
            Body=markdown_content,
            ContentType='text/markdown',
            Metadata={
                "document_type": "service_profile",
                "generation_date": datetime.utcnow().isoformat()
            }
        )
        
        logger.info(f"Stored original service profile for service: {service_id}")
        
    except Exception as e:
        logger.error(f"Error storing service profile outputs: {str(e)}")
        raise

def create_security_research_profile_prompt(service_name, iam_model, business_use_cases, validated_actions, validated_parameters):
    """Create comprehensive Security Research Profile prompt with ALL service information"""
    try:
        # Extract comprehensive information
        actions_summary = "\n".join([
            f"- {action['action_name']}: {action.get('description', 'N/A')}"
            for action in validated_actions[:30]  # More actions for better context
        ])
        
        parameters_summary = "\n".join([
            f"- {param['parameter_name']}: {param.get('description', 'N/A')} (Type: {param.get('type', 'N/A')})"
            for param in validated_parameters[:20]  # Include parameters for architecture understanding
        ])
        
        personas_summary = "\n".join([
            f"- {uc['persona']} ({uc['identity_type']}): {', '.join(uc['activities'][:3])}"
            for uc in business_use_cases.get('use_cases', [])[:5]
        ])
        
        constraints = business_use_cases.get('constraints', 'No constraints documented')
        purpose = business_use_cases.get('purpose', 'N/A')
        scope = business_use_cases.get('scope', 'N/A')
        
        # Analyze service characteristics from parameters and actions
        has_encryption = any('encrypt' in p.get('parameter_name', '').lower() or 'kms' in p.get('parameter_name', '').lower() 
                            for p in validated_parameters)
        has_vpc = any('vpc' in p.get('parameter_name', '').lower() or 'subnet' in p.get('parameter_name', '').lower() 
                     for p in validated_parameters)
        has_logging = any('log' in p.get('parameter_name', '').lower() or 'cloudwatch' in p.get('parameter_name', '').lower() 
                         for p in validated_parameters)
        
        return {
            "prompt": f"""Generate a comprehensive Security Research Profile for {service_name} for enterprise security evaluation.

This profile must go BEYOND just IAM permissions and cover the complete service architecture, operational characteristics, 
compliance posture, and security controls similar to enterprise security questionnaires.

## Available Data Sources

### Service Purpose & Scope
**Purpose**: {purpose}
**Scope**: {scope}

### CloudFormation Parameters ({len(validated_parameters)} total)
{parameters_summary}
{'... and ' + str(len(validated_parameters) - 20) + ' more parameters' if len(validated_parameters) > 20 else ''}

### IAM Actions ({len(validated_actions)} total)
{actions_summary}
{'... and ' + str(len(validated_actions) - 30) + ' more actions' if len(validated_actions) > 30 else ''}

### Business Use Cases ({len(business_use_cases.get('use_cases', []))} personas)
{personas_summary}

### Service Constraints & Limits
{constraints}

### Detected Capabilities
- Encryption Support: {'Yes' if has_encryption else 'Unknown'}
- VPC Integration: {'Yes' if has_vpc else 'Unknown'}
- Logging Capabilities: {'Yes' if has_logging else 'Unknown'}

---

## Output Requirements

Generate a comprehensive Security Research Profile in Markdown format with these sections:

### 1. Service Description
Write a technical paragraph (200-300 words) for architects/SREs covering:
- Service architecture and how it works (Layer/protocol if applicable)
- Core functionality and key capabilities
- Integration patterns (VPC, endpoints, other AWS services)
- Data flow and processing model
- Deployment model (regional, global, zonal)
- Performance characteristics (throughput, latency, scalability)

**Style**: Technical, engineering-focused, factual. Use specific technical terms. Avoid marketing language.

**Example**: "Network Load Balancer (NLB) operates at Layer 4 (transport layer) of the OSI model, distributing TCP, 
UDP, and TLS traffic across multiple targets in one or more Availability Zones. It handles millions of requests per 
second with ultra-low latency, using flow hash algorithms based on protocol, source/destination IPs, ports, and TCP 
sequence numbers..."

### 2. Major Findings Summary
List 5-8 critical security/operational characteristics:
- Data handling model (process vs store, encryption at rest/transit)
- Compliance certifications (if known)
- Service maturity (GA, Preview, Regional availability)
- Key limitations from constraints
- Notable security features

**Format**: Bullet points starting with "From AWS:" header

### 3. Provider Questions - Rapid Pilot Enablement

#### Data Protection

**Q1: Does the service process or store customer data?**
- Process (compute): [ ] Yes / [ ] No / [ ] System Metadata Only
- Store (persists): [ ] Yes / [ ] No / [ ] System Metadata Only
- Explanation: (2-3 sentences based on service architecture and parameters)

**Q2: Encryption at rest?**
- Available: [ ] Yes / [ ] No / [ ] N/A
- Default: [ ] Enabled / [ ] Disabled / [ ] N/A
- CMEK Support: [ ] Yes / [ ] No / [ ] N/A
- Details: (Check for KMS, encryption-related parameters)

**Q3: Encryption in transit?**
- Available: [ ] Yes / [ ] No / [ ] N/A
- Default: [ ] Enabled / [ ] Disabled / [ ] N/A
- Details: (Check for TLS, SSL parameters; specify version and protocols)

#### Network Controls

**Q4: VPC Integration?**
- Type: [ ] VPC-native / [ ] VPC endpoints / [ ] Public service / [ ] Hybrid
- Details: (PrivateLink support, network isolation)

**Q5: Service endpoints?**
- Scope: [ ] Regional / [ ] Global / [ ] Zonal
- Details: (Public vs private endpoint options)

#### Access Controls

**Q6: IAM integration?**
- Resource-based policies: [ ] Yes / [ ] No
- Identity-based policies: [ ] Yes / [ ] No
- Service-linked roles: [ ] Yes / [ ] No
- Details: (Analyze IAM actions to determine support; list key permission patterns)

**Q7: Fine-grained access control?**
- Condition keys: [ ] Available / [ ] Limited / [ ] None
- Resource-level permissions: [ ] Yes / [ ] No
- Details: (Check IAM actions for resource ARN patterns and condition key support)

### 4. Provider Questions - Full Production Enablement

#### Data Protection

**Q8: Data residency controls?**
- Regional guarantees: [ ] Yes / [ ] No
- Details: (Check service deployment model; discuss cross-region replication and data sovereignty)

**Q9: Data lifecycle management?**
- Retention policies: [ ] Supported / [ ] Not supported
- Details: (Check for retention, deletion, backup parameters and actions)

#### Access Controls

**Q10: Access logging and audit?**
- CloudTrail: [ ] Supported / [ ] Not supported
- Service logs: [ ] Available / [ ] Not available
- Details: (Check for CloudWatch, CloudTrail, logging parameters; specify log types and retention)

#### Isolation Controls

**Q11: Multi-tenancy model?**
- Type: [ ] Shared / [ ] Dedicated / [ ] Configurable
- Details: (Infer from service type; discuss isolation boundaries and cross-tenant protections)

**Q12: Resource isolation?**
- VPC isolation: [ ] Supported / [ ] Not supported
- Details: (Check for VPC, security group, network segmentation parameters)

#### Management & Operations

**Q13: Monitoring and observability?**
- CloudWatch metrics: [ ] Available / [ ] Limited / [ ] None
- Details: (Check for CloudWatch, metrics parameters; list key metrics and alerting capabilities)

**Q14: Compliance and governance?**
- AWS Config: [ ] Supported / [ ] Not supported
- Details: (Research service compliance certifications; discuss audit capabilities)

**Q15: Service quotas and limits?**
- Key quotas: (List from constraints)
- Details: (Soft vs hard limits, increase process)

---

## Generation Guidelines

### Data Source Usage
1. **CloudFormation Parameters** → Architecture understanding, encryption support, VPC integration, configuration options
2. **IAM Actions** → Access control capabilities (Q6, Q7), operational permissions, service integration
3. **Business Use Cases** → Common usage patterns, personas, real-world scenarios
4. **Service Constraints** → Service limits and quotas (Q15), scalability boundaries
5. **Purpose & Scope** → Service description context, intended use cases

### Answer Quality Requirements
- **Comprehensive**: Cover ALL aspects - architecture, security, operations, compliance, not just IAM
- **Technical**: Use specific technical terms (Layer 4, TCP/UDP, flow hash, etc.)
- **Factual**: Base answers on actual service capabilities from parameters and actions
- **Specific**: Include numbers, protocols, versions (e.g., "TLS 1.2+", "10,000 parameters per region")
- **Objective**: State facts, not marketing claims
- **Concise**: 2-3 sentences per answer, but comprehensive coverage

### Checkbox Selection Logic

**CRITICAL**: Mark checkboxes with [X] based on ACTUAL service capabilities, not assumptions.

**How to mark checkboxes**:
- Use `[X]` for the option that applies (e.g., `[X] Yes` or `[ ] No`)
- Leave other options unmarked with `[ ]`
- Only mark ONE option per line

**Decision criteria**:
- **Data Processing**: Check parameters for compute/processing capabilities → Mark "Yes" if service executes code/queries
- **Data Storage**: Check parameters for persistence (databases, storage, caches) → Mark "Yes" if service stores data
- **Encryption**: Check for KMS, encryption-related parameters → Mark "Yes" if encryption parameters exist
- **VPC**: Check for VPC, subnet, security group parameters → Mark "VPC-native" if VPC parameters exist
- **Logging**: Check for CloudWatch, CloudTrail, logging parameters → Mark "Supported" if logging parameters exist
- **IAM**: Check IAM actions for resource policies, roles, conditions → Mark "Yes" if corresponding actions exist

**Example**:
- If service has KMS parameters: `- Available: [X] Yes / [ ] No / [ ] N/A`
- If service has no VPC parameters: `- VPC isolation: [ ] Supported / [X] Not supported`

### Architecture Details to Include
- Deployment model (regional/global/zonal)
- Network layer operation (Layer 3/4/7)
- Data flow patterns
- Integration points
- Performance characteristics
- Scalability model

## Output Format

Return ONLY the Markdown document. Do NOT include:
- Introductory text like "Here is the profile..."
- Explanations about what you did
- Markdown code fences (```markdown)
- Any text before or after the profile

Start directly with: # Security Research Profile for {service_name}


"""
        }
    except Exception as e:
        logger.error(f"Error creating Security Research Profile prompt: {str(e)}")
        raise e

def store_security_research_profile(service_id, markdown_content):
    """Store Security Research Profile in S3 (service-profiles folder)"""
    try:
        # Store markdown version in service-profiles folder alongside profile.json and profile.md
        s3_client.put_object(
            Bucket=OUTPUT_BUCKET,
            Key=f"{service_id}/service-profiles/security_research_profile.md",
            Body=markdown_content,
            ContentType='text/markdown',
            Metadata={
                "document_type": "security_research_profile",
                "generation_date": datetime.utcnow().isoformat()
            }
        )
        
        logger.info(f"Stored Security Research Profile for service: {service_id} in service-profiles folder")
        
    except Exception as e:
        logger.error(f"Error storing Security Research Profile: {str(e)}")
        raise

def get_service_full_name(service_id):
    """Map service ID to full name"""
    service_names = {
        'sqs': 'Amazon Simple Queue Service',
        's3': 'Amazon Simple Storage Service',
        'ec2': 'Amazon Elastic Compute Cloud',
        'rds': 'Amazon Relational Database Service',
        'lambda': 'AWS Lambda',
        'dynamodb': 'Amazon DynamoDB'
    }
    return service_names.get(service_id, service_id.upper())

def lambda_handler(event, context):
    """Lambda handler for generating service profiles"""
    try:
        logger.info("Starting GenerateServiceProfile Lambda")
        
        result = generate_service_profile(event)
        
        logger.info("Successfully completed service profile generation")
        return result
        
    except Exception as e:
        logger.error(f"Error in GenerateServiceProfile: {str(e)}")
        raise
