import { APIGatewayProxyEvent, APIGatewayProxyResult, Context } from 'aws-lambda';

/**
 * Simple Lambda handler for basic API functionality
 */
export const handler = async (event: APIGatewayProxyEvent, context: Context): Promise<APIGatewayProxyResult> => {
  console.log('API Gateway event:', JSON.stringify(event, null, 2));

  const { httpMethod, path, pathParameters } = event;

  // CORS headers
  const headers = {
    'Content-Type': 'application/json',
    'Access-Control-Allow-Origin': '*',
    'Access-Control-Allow-Methods': 'GET, POST, PUT, DELETE, OPTIONS',
    'Access-Control-Allow-Headers': 'Content-Type, Authorization',
  };

  // Handle OPTIONS requests for CORS
  if (httpMethod === 'OPTIONS') {
    return {
      statusCode: 200,
      headers,
      body: '',
    };
  }

  try {
    // Route handling
    if (path === '/api/v1/health' || path === '/health') {
      return {
        statusCode: 200,
        headers,
        body: JSON.stringify({
          status: 'ok',
          message: 'Investment AI Agent API is running',
          timestamp: new Date().toISOString(),
          version: '1.0.0'
        }),
      };
    }

    // Serve demo UI
    if (path === '/' || path === '/demo') {
      return {
        statusCode: 200,
        headers: {
          'Content-Type': 'text/html',
          'Access-Control-Allow-Origin': '*',
        },
        body: getDemoHTML(),
      };
    }

    if (path === '/api/v1/version' || path === '/version') {
      return {
        statusCode: 200,
        headers,
        body: JSON.stringify({
          version: '1.0.0',
          name: 'Investment AI Agent',
          description: 'Multi-Agent AI System for Investment Research & Recommendations',
          timestamp: new Date().toISOString()
        }),
      };
    }

    // Demo endpoints (rate limited, no auth required)
    if (path === '/api/v1/demo/health') {
      return {
        statusCode: 200,
        headers,
        body: JSON.stringify({
          status: 'ok',
          message: 'Investment AI Agent Demo API is running',
          timestamp: new Date().toISOString(),
          version: '1.0.0',
          mode: 'demo',
          rateLimited: true
        }),
      };
    }

    if (path === '/api/v1/demo/version') {
      return {
        statusCode: 200,
        headers,
        body: JSON.stringify({
          version: '1.0.0',
          name: 'Investment AI Agent (Demo)',
          description: 'Multi-Agent AI System for Investment Research & Recommendations - Demo Mode',
          timestamp: new Date().toISOString(),
          mode: 'demo',
          rateLimited: true,
          features: {
            authentication: false,
            rateLimit: '5 requests/minute',
            fullFeatures: false
          }
        }),
      };
    }

    if (path === '/api/v1/demo/ideas') {
      try {
        // Call the real AI orchestration service for demo
        const aiGeneratedIdeas = await generateInvestmentIdeasWithAI();

        return {
          statusCode: 200,
          headers,
          body: JSON.stringify({
            ideas: aiGeneratedIdeas,
            timestamp: new Date().toISOString(),
            mode: 'demo',
            rateLimited: true,
            aiGenerated: true,
            disclaimer: 'These investment ideas are generated by AI for demonstration purposes only. Not financial advice.',
            models: ['Claude Sonnet 3.7', 'Claude Haiku 3.5', 'Amazon Nova Pro']
          }),
        };
      } catch (error) {
        console.error('AI generation failed, falling back to static data:', error);

        // Fallback to static data if AI fails
        return {
          statusCode: 200,
          headers,
          body: JSON.stringify({
            ideas: [
              {
                id: 'demo-fallback-1',
                title: 'Technology Sector ETF (Fallback)',
                description: 'Diversified technology sector investment with focus on AI and cloud computing companies.',
                riskLevel: 'moderate',
                expectedReturn: '8-12% annually',
                timeHorizon: 'medium-term',
                confidence: 0.75,
                reasoning: 'Strong growth in AI and cloud adoption driving sector performance.',
                mode: 'demo-fallback'
              }
            ],
            timestamp: new Date().toISOString(),
            mode: 'demo',
            rateLimited: true,
            aiGenerated: false,
            error: 'AI generation temporarily unavailable',
            disclaimer: 'These are sample investment ideas for demonstration purposes only. Not financial advice.'
          }),
        };
      }
    }

    // Async endpoints for production workflows (check BEFORE general ideas endpoint)
    if (path === '/api/v1/ideas/async' && httpMethod === 'POST') {
      try {
        console.log('Processing async investment ideas request...');
        
        // Parse request body
        const requestBody = event.body ? JSON.parse(event.body) : {};
        
        // Generate job ID
        const jobId = `job_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
        
        // Extract user preferences
        const userPreferences = {
          riskTolerance: requestBody.riskTolerance || 'moderate',
          investmentHorizon: requestBody.investmentHorizon || 'medium-term',
          sectors: requestBody.sectors || ['technology', 'healthcare', 'finance'],
          maxIdeas: requestBody.maxIdeas || 5,
          includeAnalysis: requestBody.includeAnalysis !== false,
          customRequirements: requestBody.customRequirements || '',
          excludedInvestments: requestBody.excludedInvestments || []
        };

        // Store job in DynamoDB
        const jobData = {
          jobId,
          userId: 'demo-user', // In production, extract from JWT
          status: 'queued',
          userPreferences,
          createdAt: new Date().toISOString(),
          estimatedCompletion: new Date(Date.now() + 60000).toISOString(), // 1 minute estimate
          ttl: Math.floor(Date.now() / 1000) + (7 * 24 * 60 * 60) // 7 days TTL
        };

        // Store job metadata (in production, this would be DynamoDB)
        console.log('Created async job:', jobId);
        
        // In production: send to SQS queue for background processing
        // For demo: just log that it's queued

        return {
          statusCode: 202,
          headers,
          body: JSON.stringify({
            jobId,
            status: 'queued',
            statusUrl: `/api/v1/jobs/${jobId}/status`,
            resultsUrl: `/api/v1/jobs/${jobId}/results`,
            estimatedCompletion: jobData.estimatedCompletion,
            message: 'Multi-agent analysis job queued successfully'
          }),
        };
      } catch (error) {
        console.error('Error creating async job:', error);
        
        return {
          statusCode: 500,
          headers,
          body: JSON.stringify({
            error: 'Job Creation Failed',
            message: 'Failed to queue multi-agent analysis job'
          }),
        };
      }
    }

    // Protected endpoints - require authentication
    if (path.startsWith('/api/v1/ideas')) {
      // Temporarily remove authorization check for testing multi-agent workflow
      console.log('Processing authenticated endpoint (auth temporarily disabled for testing)...');

      // Real multi-agent orchestration for authenticated users
      if (httpMethod === 'GET') {
        try {
          console.log('Processing authenticated investment ideas request...');
          
          // Extract user preferences from query parameters or use defaults
          const queryParams = event.queryStringParameters || {};
          const userPreferences = {
            riskTolerance: queryParams.riskTolerance || 'moderate',
            investmentHorizon: queryParams.investmentHorizon || 'medium-term',
            sectors: queryParams.sectors ? queryParams.sectors.split(',') : ['technology', 'healthcare', 'finance'],
            maxIdeas: parseInt(queryParams.maxIdeas || '5'),
            includeAnalysis: queryParams.includeAnalysis === 'true'
          };

          // Call the full multi-agent orchestration system
          const orchestrationResult = await generateInvestmentIdeasWithMultiAgentOrchestration(userPreferences);

          return {
            statusCode: 200,
            headers,
            body: JSON.stringify({
              ideas: orchestrationResult.ideas,
              metadata: orchestrationResult.metadata,
              processingMetrics: orchestrationResult.processingMetrics,
              timestamp: new Date().toISOString(),
              mode: 'production',
              authenticated: true,
              multiAgent: true,
              models: orchestrationResult.modelsUsed || ['Claude Sonnet 3.7', 'Claude Haiku 3.5', 'Amazon Nova Pro']
            }),
          };
        } catch (error) {
          console.error('Error in multi-agent orchestration:', error);
          
          return {
            statusCode: 500,
            headers,
            body: JSON.stringify({
              error: 'Multi-Agent Processing Failed',
              message: 'The AI orchestration system encountered an error. Please try again.',
              timestamp: new Date().toISOString(),
              mode: 'production',
              authenticated: true
            }),
          };
        }
      }

      if (httpMethod === 'POST') {
        try {
          console.log('Processing authenticated POST investment ideas request...');
          
          // Parse request body
          const requestBody = event.body ? JSON.parse(event.body) : {};
          
          // Extract user preferences from request body
          const userPreferences = {
            riskTolerance: requestBody.riskTolerance || 'moderate',
            investmentHorizon: requestBody.investmentHorizon || 'medium-term',
            sectors: requestBody.sectors || ['technology', 'healthcare', 'finance'],
            maxIdeas: requestBody.maxIdeas || 5,
            includeAnalysis: requestBody.includeAnalysis !== false,
            customRequirements: requestBody.customRequirements || '',
            excludedInvestments: requestBody.excludedInvestments || []
          };

          console.log('User preferences:', userPreferences);

          // Call the full multi-agent orchestration system
          const orchestrationResult = await generateInvestmentIdeasWithMultiAgentOrchestration(userPreferences);

          return {
            statusCode: 201,
            headers,
            body: JSON.stringify({
              requestId: `req-${Date.now()}`,
              status: 'completed',
              ideas: orchestrationResult.ideas,
              metadata: orchestrationResult.metadata,
              processingMetrics: orchestrationResult.processingMetrics,
              userPreferences,
              timestamp: new Date().toISOString(),
              mode: 'production',
              authenticated: true,
              multiAgent: true,
              models: orchestrationResult.modelsUsed || ['Claude Sonnet 3.7', 'Claude Haiku 3.5', 'Amazon Nova Pro']
            }),
          };
        } catch (error) {
          console.error('Error in POST multi-agent orchestration:', error);
          
          return {
            statusCode: 500,
            headers,
            body: JSON.stringify({
              error: 'Multi-Agent Processing Failed',
              message: 'The AI orchestration system encountered an error processing your custom request.',
              timestamp: new Date().toISOString(),
              mode: 'production',
              authenticated: true
            }),
          };
        }
      }
    }



    // Job status endpoint
    if (path.startsWith('/api/v1/jobs/') && path.endsWith('/status') && httpMethod === 'GET') {
      const jobId = path.split('/')[4]; // Extract jobId from path
      
      try {
        // In production, query DynamoDB for job status
        // For demo, return mock status based on job age
        const jobAge = Date.now() - parseInt(jobId.split('_')[1]);
        
        let status, progress;
        if (jobAge < 10000) {
          status = 'queued';
          progress = { percentComplete: 0, currentStep: 'queued' };
        } else if (jobAge < 20000) {
          status = 'processing';
          progress = { percentComplete: 20, currentStep: 'planning' };
        } else if (jobAge < 35000) {
          status = 'processing';
          progress = { percentComplete: 40, currentStep: 'research' };
        } else if (jobAge < 50000) {
          status = 'processing';
          progress = { percentComplete: 60, currentStep: 'analysis' };
        } else if (jobAge < 65000) {
          status = 'processing';
          progress = { percentComplete: 80, currentStep: 'synthesis' };
        } else {
          status = 'completed';
          progress = { percentComplete: 100, currentStep: 'completed' };
        }

        return {
          statusCode: 200,
          headers,
          body: JSON.stringify({
            jobId,
            status,
            progress,
            processingTime: jobAge,
            estimatedTimeRemaining: status === 'completed' ? 0 : Math.max(0, 60000 - jobAge),
            agentProgress: {
              planning: jobAge > 20000 ? 'completed' : jobAge > 10000 ? 'in_progress' : 'pending',
              research: jobAge > 35000 ? 'completed' : jobAge > 20000 ? 'in_progress' : 'pending',
              analysis: jobAge > 50000 ? 'completed' : jobAge > 35000 ? 'in_progress' : 'pending',
              compliance: jobAge > 65000 ? 'completed' : jobAge > 50000 ? 'in_progress' : 'pending',
              synthesis: jobAge > 65000 ? 'completed' : 'pending'
            }
          }),
        };
      } catch (error) {
        return {
          statusCode: 404,
          headers,
          body: JSON.stringify({
            error: 'Job Not Found',
            message: `Job ${jobId} not found`
          }),
        };
      }
    }

    // Job results endpoint
    if (path.startsWith('/api/v1/jobs/') && path.endsWith('/results') && httpMethod === 'GET') {
      const jobId = path.split('/')[4];
      
      try {
        const jobAge = Date.now() - parseInt(jobId.split('_')[1]);
        
        if (jobAge < 65000) {
          return {
            statusCode: 202,
            headers,
            body: JSON.stringify({
              jobId,
              status: 'processing',
              message: 'Job is still processing. Results not yet available.'
            }),
          };
        }

        // Return mock results for completed job
        return {
          statusCode: 200,
          headers,
          body: JSON.stringify({
            jobId,
            status: 'completed',
            results: {
              ideas: [
                {
                  id: `async-${jobId}-1`,
                  title: 'Multi-Agent Generated Tech Portfolio',
                  description: 'Comprehensive technology sector investment strategy generated through full 5-agent AI orchestration including planning, research, analysis, compliance, and synthesis.',
                  riskLevel: 'moderate',
                  expectedReturn: '9-13% annually',
                  timeHorizon: 'medium-term',
                  confidence: 0.88,
                  reasoning: 'Generated through complete multi-agent workflow with comprehensive market analysis and compliance checking',
                  sectors: ['technology', 'artificial-intelligence'],
                  complianceNotes: 'Fully reviewed by AI compliance agent',
                  mode: 'async-production',
                  multiAgent: true,
                  agentsUsed: ['Planning', 'Research', 'Analysis', 'Compliance', 'Synthesis']
                }
              ],
              metadata: {
                totalIdeasGenerated: 1,
                multiAgentWorkflow: true,
                processingTime: jobAge,
                agentsUsed: ['Planning Agent', 'Research Agent', 'Analysis Agent', 'Compliance Agent', 'Synthesis Agent']
              }
            },
            completedAt: new Date().toISOString(),
            totalProcessingTime: jobAge
          }),
        };
      } catch (error) {
        return {
          statusCode: 404,
          headers,
          body: JSON.stringify({
            error: 'Job Not Found',
            message: `Job ${jobId} not found`
          }),
        };
      }
    }

    // Default 404 response
    return {
      statusCode: 404,
      headers,
      body: JSON.stringify({
        error: 'Not Found',
        message: `Path ${path} not found`,
        availableEndpoints: [
          'GET /api/v1/health',
          'GET /api/v1/version',
          'GET /api/v1/ideas',
          'POST /api/v1/ideas'
        ]
      }),
    };

  } catch (error) {
    console.error('Lambda error:', error);

    return {
      statusCode: 500,
      headers,
      body: JSON.stringify({
        error: 'Internal Server Error',
        message: 'An unexpected error occurred'
      }),
    };
  }
};

function getDemoHTML(): string {
  return `<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Investment AI Agent - Live Demo</title>
    <link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/css/all.min.css" rel="stylesheet">
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            padding: 20px;
        }
        .container { max-width: 1200px; margin: 0 auto; }
        .header {
            text-align: center;
            color: white;
            margin-bottom: 40px;
        }
        .header h1 {
            font-size: 3rem;
            margin-bottom: 10px;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.3);
        }
        .demo-card {
            background: white;
            border-radius: 20px;
            padding: 40px;
            box-shadow: 0 20px 40px rgba(0,0,0,0.1);
            margin-bottom: 30px;
        }
        .demo-button {
            background: linear-gradient(135deg, #667eea, #764ba2);
            color: white;
            border: none;
            padding: 15px 30px;
            border-radius: 10px;
            font-size: 16px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
            display: flex;
            align-items: center;
            gap: 10px;
            justify-content: center;
            margin: 10px;
        }
        .demo-button:hover {
            transform: translateY(-2px);
            box-shadow: 0 10px 20px rgba(102, 126, 234, 0.3);
        }
        .demo-button:disabled {
            opacity: 0.6;
            cursor: not-allowed;
            transform: none;
        }
        .response-area {
            background: #f8f9fa;
            border: 1px solid #e9ecef;
            border-radius: 10px;
            padding: 20px;
            margin-top: 20px;
            font-family: 'Courier New', monospace;
            font-size: 14px;
            max-height: 400px;
            overflow-y: auto;
        }
        .investment-ideas {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
            gap: 20px;
            margin-top: 20px;
        }
        .idea-card {
            background: white;
            border: 1px solid #e9ecef;
            border-radius: 15px;
            padding: 20px;
            box-shadow: 0 5px 15px rgba(0,0,0,0.08);
        }
        .idea-title {
            font-size: 1.2rem;
            font-weight: 600;
            color: #333;
            margin-bottom: 10px;
        }
        .idea-description {
            color: #666;
            margin-bottom: 15px;
            line-height: 1.5;
        }
        .risk-badge {
            padding: 4px 12px;
            border-radius: 20px;
            font-size: 12px;
            font-weight: 600;
            text-transform: uppercase;
        }
        .risk-conservative { background: #d4edda; color: #155724; }
        .risk-moderate { background: #fff3cd; color: #856404; }
        .risk-aggressive { background: #f8d7da; color: #721c24; }
        .rate-limit-notice {
            background: #fff3cd;
            border: 1px solid #ffeaa7;
            border-radius: 10px;
            padding: 15px;
            margin-bottom: 20px;
            color: #856404;
        }
        .success { color: #28a745; }
        .error { color: #dc3545; }
        .warning { color: #ffc107; }
        .spinner { animation: spin 1s linear infinite; }
        @keyframes spin { from { transform: rotate(0deg); } to { transform: rotate(360deg); } }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1><i class="fas fa-chart-line"></i> Investment AI Agent</h1>
            <p>üöÄ Live Demo - Multi-Agent AI System for Investment Research</p>
            <p>‚úÖ Successfully Deployed on AWS Lambda + API Gateway</p>
            <p>ü§ñ Powered by Amazon Bedrock: Claude Sonnet 3.7, Claude Haiku 3.5, Amazon Nova Pro</p>
        </div>

        <div class="rate-limit-notice">
            <i class="fas fa-robot"></i> <strong>AI-Powered Demo:</strong> This demo uses real Amazon Bedrock models (Claude Sonnet 3.7) to generate investment ideas. 
            Rate-limited for demo purposes. For full multi-agent orchestration, use the authenticated API endpoints.
        </div>

        <div class="demo-card">
            <h2><i class="fas fa-play"></i> Interactive Demo (Rate Limited)</h2>
            
            <div style="display: flex; flex-wrap: wrap; gap: 10px; justify-content: center;">
                <button class="demo-button" onclick="performHealthCheck()">
                    <i class="fas fa-heartbeat"></i> Health Check
                </button>
                <button class="demo-button" onclick="getInvestmentIdeas()">
                    <i class="fas fa-lightbulb"></i> Get Investment Ideas
                </button>
                <button class="demo-button" onclick="getVersion()">
                    <i class="fas fa-info-circle"></i> Version Info
                </button>
            </div>

            <div id="response-area" class="response-area" style="display: none;"></div>
            <div id="investment-ideas" class="investment-ideas"></div>
        </div>

        <div class="demo-card">
            <h2><i class="fas fa-code"></i> API Information</h2>
            
            <h3>Demo Endpoints (Rate Limited - No Authentication)</h3>
            <p><strong>Base URL:</strong> https://fflo4lgd6d.execute-api.us-west-2.amazonaws.com/v1</p>
            <ul>
                <li><strong>Demo Health Check:</strong> GET /api/v1/demo/health (10 req/min)</li>
                <li><strong>Demo Investment Ideas:</strong> GET /api/v1/demo/ideas (5 req/min)</li>
                <li><strong>Demo Version Info:</strong> GET /api/v1/demo/version (10 req/min)</li>
            </ul>
            
            <h3>Production Endpoints (Authenticated - No Rate Limits)</h3>
            <ul>
                <li><strong>Health Check:</strong> GET /api/v1/health</li>
                <li><strong>Investment Ideas:</strong> GET /api/v1/ideas (requires auth)</li>
                <li><strong>Version Info:</strong> GET /api/v1/version</li>
            </ul>
            
            <h3 style="margin-top: 20px;">Sample cURL Commands:</h3>
            <div class="response-area">
# Demo endpoints (no auth, rate limited)
curl https://fflo4lgd6d.execute-api.us-west-2.amazonaws.com/v1/api/v1/demo/health
curl https://fflo4lgd6d.execute-api.us-west-2.amazonaws.com/v1/api/v1/demo/ideas

# Production endpoints (auth required, no rate limits)
curl https://fflo4lgd6d.execute-api.us-west-2.amazonaws.com/v1/api/v1/health
curl -H "Authorization: Bearer YOUR_TOKEN" \\
  https://fflo4lgd6d.execute-api.us-west-2.amazonaws.com/v1/api/v1/ideas
            </div>
        </div>
    </div>

    <script>
        const API_BASE = window.location.origin + '/v1';
        let requestCount = { health: 0, ideas: 0, version: 0 };
        
        async function performHealthCheck() {
            if (requestCount.health >= 10) {
                showResponse('‚ùå Rate limit exceeded for health check (10/min)', 'error');
                return;
            }
            
            showResponse('Performing health check...');
            try {
                const response = await fetch(API_BASE + '/api/v1/demo/health');
                const data = await response.json();
                requestCount.health++;
                showResponse('‚úÖ Health Check Successful\\n\\n' + JSON.stringify(data, null, 2), 'success');
            } catch (error) {
                showResponse('‚ùå Health Check Failed\\n\\n' + error.message, 'error');
            }
        }

        async function getInvestmentIdeas() {
            if (requestCount.ideas >= 5) {
                showResponse('‚ùå Rate limit exceeded for investment ideas (5/min)', 'error');
                return;
            }
            
            showResponse('Generating investment ideas...');
            try {
                const response = await fetch(API_BASE + '/api/v1/demo/ideas');
                const data = await response.json();
                requestCount.ideas++;
                showResponse('‚úÖ Investment Ideas Retrieved\\n\\n' + JSON.stringify(data, null, 2), 'success');
                displayInvestmentIdeas(data.ideas || []);
            } catch (error) {
                showResponse('‚ùå Failed to Get Ideas\\n\\n' + error.message, 'error');
            }
        }

        async function getVersion() {
            if (requestCount.version >= 10) {
                showResponse('‚ùå Rate limit exceeded for version info (10/min)', 'error');
                return;
            }
            
            showResponse('Getting version information...');
            try {
                const response = await fetch(API_BASE + '/api/v1/demo/version');
                const data = await response.json();
                requestCount.version++;
                showResponse('‚úÖ Version Info Retrieved\\n\\n' + JSON.stringify(data, null, 2), 'success');
            } catch (error) {
                showResponse('‚ùå Failed to Get Version\\n\\n' + error.message, 'error');
            }
        }

        function showResponse(text, type = '') {
            const area = document.getElementById('response-area');
            area.style.display = 'block';
            area.innerHTML = '<pre class="' + type + '">' + text + '</pre>';
        }

        function displayInvestmentIdeas(ideas) {
            const container = document.getElementById('investment-ideas');
            if (!ideas || ideas.length === 0) {
                container.innerHTML = '<p>No investment ideas available.</p>';
                return;
            }
            container.innerHTML = ideas.map(idea => 
                '<div class="idea-card">' +
                '<div class="idea-title">' + idea.title + '</div>' +
                '<div class="idea-description">' + idea.description + '</div>' +
                '<span class="risk-badge risk-' + idea.riskLevel + '">' + idea.riskLevel + ' Risk</span>' +
                (idea.expectedReturn ? '<div style="margin-top: 10px; font-weight: 600; color: #28a745;">Expected Return: ' + idea.expectedReturn + '</div>' : '') +
                (idea.mode === 'demo' ? '<div style="margin-top: 5px; font-size: 12px; color: #6c757d;">Demo Mode</div>' : '') +
                '</div>'
            ).join('');
        }

        // Reset rate limits every minute
        setInterval(() => {
            requestCount = { health: 0, ideas: 0, version: 0 };
        }, 60000);
    </script>
</body>
</html>`;
}

/**
 * Generate investment ideas using Bedrock models directly
 */
async function generateInvestmentIdeasWithAI(): Promise<any[]> {
  try {
    // Import AWS SDK for Bedrock
    const { BedrockRuntimeClient, InvokeModelCommand } = await import('@aws-sdk/client-bedrock-runtime');

    // Initialize Bedrock client
    const bedrockClient = new BedrockRuntimeClient({
      region: process.env.AWS_REGION || 'us-west-2'
    });

    // Create a prompt for investment idea generation
    const prompt = `You are an expert investment advisor. Generate 3 diverse investment ideas for a moderate risk investor with a medium-term investment horizon (2-5 years). Focus on different sectors like technology, healthcare, and renewable energy.

For each investment idea, provide:
1. A clear title
2. A brief description (2-3 sentences)
3. Risk level (conservative/moderate/aggressive)
4. Expected annual return range
5. Brief reasoning

Format your response as a JSON array with this structure:
[
  {
    "title": "Investment Title",
    "description": "Brief description of the investment opportunity",
    "riskLevel": "moderate",
    "expectedReturn": "X-Y% annually",
    "reasoning": "Brief explanation of why this is a good opportunity"
  }
]

Generate realistic, diverse investment ideas that would be suitable for a moderate risk investor.`;

    // Call Claude Sonnet 3.7 for investment idea generation
    const claudeRequest = {
      modelId: 'us.anthropic.claude-3-7-sonnet-20250219-v1:0',
      contentType: 'application/json',
      accept: 'application/json',
      body: JSON.stringify({
        anthropic_version: 'bedrock-2023-05-31',
        max_tokens: 2000,
        temperature: 0.7,
        messages: [
          {
            role: 'user',
            content: prompt
          }
        ]
      })
    };

    console.log('Calling Claude Sonnet 3.7 for investment ideas...');
    const command = new InvokeModelCommand(claudeRequest);
    const response = await bedrockClient.send(command);

    // Parse the response
    const responseBody = JSON.parse(new TextDecoder().decode(response.body));
    console.log('Claude response:', responseBody);

    // Extract the investment ideas from Claude's response
    const claudeText = responseBody.content[0].text;

    // Try to parse JSON from Claude's response
    let ideas = [];
    try {
      // Look for JSON array in the response
      const jsonMatch = claudeText.match(/\[[\s\S]*\]/);
      if (jsonMatch) {
        const parsedIdeas = JSON.parse(jsonMatch[0]);
        ideas = parsedIdeas.map((idea: any, index: number) => ({
          id: `claude-demo-${index + 1}`,
          title: idea.title || `AI Investment Idea ${index + 1}`,
          description: idea.description || 'AI-generated investment opportunity',
          riskLevel: idea.riskLevel || 'moderate',
          expectedReturn: idea.expectedReturn || '6-10% annually',
          timeHorizon: 'medium-term',
          confidence: 0.85,
          reasoning: idea.reasoning || 'Generated by Claude Sonnet 3.7',
          mode: 'ai-demo',
          aiGenerated: true,
          model: 'Claude Sonnet 3.7'
        }));
      }
    } catch (parseError) {
      console.log('Could not parse JSON, extracting from text:', parseError);
      // Fallback: parse from text
      ideas = parseInvestmentIdeasFromText(claudeText);
    }

    // If no ideas extracted, create a fallback
    if (ideas.length === 0) {
      ideas = [{
        id: 'claude-demo-1',
        title: 'AI-Generated Investment Portfolio',
        description: claudeText.substring(0, 200) + (claudeText.length > 200 ? '...' : ''),
        riskLevel: 'moderate',
        expectedReturn: '7-11% annually',
        timeHorizon: 'medium-term',
        confidence: 0.8,
        reasoning: 'Generated by Claude Sonnet 3.7 using advanced AI analysis',
        mode: 'ai-demo',
        aiGenerated: true,
        model: 'Claude Sonnet 3.7'
      }];
    }

    console.log(`Generated ${ideas.length} investment ideas using Claude Sonnet 3.7`);
    return ideas.slice(0, 3); // Limit to 3 ideas

  } catch (error) {
    console.error('Error in AI generation:', error);
    throw error;
  }
}

/**
 * Extract investment ideas from AI response
 */
function extractInvestmentIdeasFromResponse(response: any): any[] {
  try {
    // The response should contain investment ideas
    if (response.investmentIdeas && Array.isArray(response.investmentIdeas)) {
      return response.investmentIdeas.map((idea: any, index: number) => ({
        id: `ai-demo-${index + 1}`,
        title: idea.title || `AI Generated Investment Idea ${index + 1}`,
        description: idea.description || idea.summary || 'AI-generated investment opportunity',
        riskLevel: idea.riskLevel || 'moderate',
        expectedReturn: idea.expectedReturn || idea.potentialReturn || '6-10% annually',
        timeHorizon: idea.timeHorizon || 'medium-term',
        confidence: idea.confidenceScore || idea.confidence || 0.8,
        reasoning: idea.reasoning || idea.rationale || 'Generated by AI multi-agent analysis',
        mode: 'ai-demo',
        aiGenerated: true,
        models: ['Claude Sonnet 3.7', 'Claude Haiku 3.5', 'Amazon Nova Pro']
      }));
    }

    // If no structured ideas, try to parse from text response
    if (response.response || response.message) {
      const text = response.response || response.message;
      return parseInvestmentIdeasFromText(text);
    }

    // Fallback: create ideas from any available data
    return [{
      id: 'ai-demo-1',
      title: 'AI-Generated Investment Opportunity',
      description: 'Investment idea generated by multi-agent AI system using Claude Sonnet 3.7, Claude Haiku 3.5, and Amazon Nova Pro',
      riskLevel: 'moderate',
      expectedReturn: '7-11% annually',
      timeHorizon: 'medium-term',
      confidence: 0.8,
      reasoning: 'Generated through comprehensive AI analysis of market conditions and investment opportunities',
      mode: 'ai-demo',
      aiGenerated: true,
      models: ['Claude Sonnet 3.7', 'Claude Haiku 3.5', 'Amazon Nova Pro']
    }];

  } catch (error) {
    console.error('Error extracting investment ideas:', error);
    throw error;
  }
}

/**
 * Parse investment ideas from text response
 */
function parseInvestmentIdeasFromText(text: string): any[] {
  try {
    // Simple parsing logic to extract investment ideas from text
    const ideas = [];
    const lines = text.split('\n');
    let currentIdea: any = null;
    let ideaCount = 0;

    for (const line of lines) {
      const trimmedLine = line.trim();

      // Look for investment idea indicators
      if (trimmedLine.match(/^\d+\.|^-|^\*/) && trimmedLine.length > 10) {
        // Save previous idea
        if (currentIdea) {
          ideas.push(currentIdea);
        }

        // Start new idea
        ideaCount++;
        currentIdea = {
          id: `ai-parsed-${ideaCount}`,
          title: trimmedLine.replace(/^\d+\.|^-|^\*/, '').trim(),
          description: '',
          riskLevel: 'moderate',
          expectedReturn: '6-10% annually',
          timeHorizon: 'medium-term',
          confidence: 0.75,
          reasoning: 'Parsed from AI-generated text response',
          mode: 'ai-demo',
          aiGenerated: true,
          models: ['Claude Sonnet 3.7', 'Claude Haiku 3.5', 'Amazon Nova Pro']
        };
      } else if (currentIdea && trimmedLine.length > 0) {
        // Add to description
        currentIdea.description += (currentIdea.description ? ' ' : '') + trimmedLine;
      }
    }

    // Add the last idea
    if (currentIdea) {
      ideas.push(currentIdea);
    }

    // If no ideas found, create a generic one
    if (ideas.length === 0) {
      ideas.push({
        id: 'ai-text-1',
        title: 'AI-Generated Investment Insight',
        description: text.substring(0, 200) + (text.length > 200 ? '...' : ''),
        riskLevel: 'moderate',
        expectedReturn: '6-10% annually',
        timeHorizon: 'medium-term',
        confidence: 0.7,
        reasoning: 'Extracted from AI-generated investment analysis',
        mode: 'ai-demo',
        aiGenerated: true,
        models: ['Claude Sonnet 3.7', 'Claude Haiku 3.5', 'Amazon Nova Pro']
      });
    }

    return ideas.slice(0, 3); // Limit to 3 ideas for demo

  } catch (error) {
    console.error('Error parsing text response:', error);
    throw error;
  }
}

/**
 * Generate investment ideas using multi-agent orchestration with Bedrock models
 */
async function generateInvestmentIdeasWithMultiAgentOrchestration(userPreferences: any): Promise<any> {
  const startTime = Date.now();
  const processingSteps: any[] = [];
  const modelsUsed: string[] = [];

  try {
    console.log('Starting multi-agent orchestration with preferences:', userPreferences);

    // Import AWS SDK for Bedrock
    const { BedrockRuntimeClient, InvokeModelCommand } = await import('@aws-sdk/client-bedrock-runtime');

    // Initialize Bedrock client
    const bedrockClient = new BedrockRuntimeClient({ 
      region: process.env.AWS_REGION || 'us-west-2' 
    });

    // Step 1: Planning Agent (Claude Sonnet 3.7) - Create research plan
    console.log('Step 1: Planning Agent - Creating research plan...');
    const planningStepStart = Date.now();
    
    const planningPrompt = `You are a financial planning agent. Create a research plan for generating ${userPreferences.maxIdeas} investment ideas with these preferences:
- Risk Tolerance: ${userPreferences.riskTolerance}
- Investment Horizon: ${userPreferences.investmentHorizon}
- Preferred Sectors: ${userPreferences.sectors.join(', ')}
- Custom Requirements: ${userPreferences.customRequirements || 'None'}

Create a structured research plan that identifies:
1. Key market areas to research
2. Risk factors to analyze
3. Specific investment types to consider
4. Analysis priorities

Respond with a JSON object containing your research plan.`;

    const planningResult = await callBedrockModel(bedrockClient, 'us.anthropic.claude-3-7-sonnet-20250219-v1:0', planningPrompt);
    modelsUsed.push('Claude Sonnet 3.7 (Planning)');
    
    processingSteps.push({
      step: 'planning',
      agent: 'Planning Agent',
      model: 'Claude Sonnet 3.7',
      duration: Date.now() - planningStepStart,
      status: 'completed'
    });

    // Step 2: Research Agent (Claude Haiku 3.5) - Gather market information
    console.log('Step 2: Research Agent - Gathering market information...');
    const researchStepStart = Date.now();
    
    const researchPrompt = `You are a financial research agent. Based on this research plan: "${planningResult.substring(0, 500)}..."

Research current market conditions and opportunities for:
- Risk Level: ${userPreferences.riskTolerance}
- Sectors: ${userPreferences.sectors.join(', ')}
- Time Horizon: ${userPreferences.investmentHorizon}

Provide current market insights, trends, and specific investment opportunities you've identified. Focus on factual, actionable research findings.`;

    const researchResult = await callBedrockModel(bedrockClient, 'us.anthropic.claude-3-5-haiku-20241022-v1:0', researchPrompt);
    modelsUsed.push('Claude Haiku 3.5 (Research)');
    
    processingSteps.push({
      step: 'research',
      agent: 'Research Agent',
      model: 'Claude Haiku 3.5',
      duration: Date.now() - researchStepStart,
      status: 'completed'
    });

    // Step 3: Analysis Agent (Amazon Nova Pro) - Financial analysis
    console.log('Step 3: Analysis Agent - Performing financial analysis...');
    const analysisStepStart = Date.now();
    
    const analysisPrompt = `You are a quantitative financial analysis agent. Analyze the research findings: "${researchResult.substring(0, 500)}..."

Perform financial analysis for investment opportunities with:
- Risk Tolerance: ${userPreferences.riskTolerance}
- Investment Horizon: ${userPreferences.investmentHorizon}
- Target Sectors: ${userPreferences.sectors.join(', ')}

Provide quantitative analysis including:
1. Expected return ranges
2. Risk assessments
3. Correlation analysis
4. Performance projections

Focus on numerical analysis and financial metrics.`;

    const analysisResult = await callBedrockModel(bedrockClient, 'us.amazon.nova-pro-v1:0', analysisPrompt);
    modelsUsed.push('Amazon Nova Pro (Analysis)');
    
    processingSteps.push({
      step: 'analysis',
      agent: 'Analysis Agent',
      model: 'Amazon Nova Pro',
      duration: Date.now() - analysisStepStart,
      status: 'completed'
    });

    // Step 4: Compliance Agent (Claude Haiku 3.5) - Risk and compliance check
    console.log('Step 4: Compliance Agent - Checking compliance and risk...');
    const complianceStepStart = Date.now();
    
    const compliancePrompt = `You are a compliance and risk management agent. Review these investment analysis results: "${analysisResult.substring(0, 500)}..."

Assess compliance and risk factors for:
- Risk Tolerance: ${userPreferences.riskTolerance}
- Investment Horizon: ${userPreferences.investmentHorizon}
- Regulatory Requirements: SEC, FINRA compliance

Identify any compliance issues, risk warnings, or regulatory considerations. Ensure all recommendations are appropriate for the stated risk tolerance.`;

    const complianceResult = await callBedrockModel(bedrockClient, 'us.anthropic.claude-3-5-haiku-20241022-v1:0', compliancePrompt);
    modelsUsed.push('Claude Haiku 3.5 (Compliance)');
    
    processingSteps.push({
      step: 'compliance',
      agent: 'Compliance Agent',
      model: 'Claude Haiku 3.5',
      duration: Date.now() - complianceStepStart,
      status: 'completed'
    });

    // Step 5: Synthesis Agent (Claude Sonnet 3.7) - Generate final investment ideas
    console.log('Step 5: Synthesis Agent - Generating final investment ideas...');
    const synthesisStepStart = Date.now();
    
    const synthesisPrompt = `You are a synthesis agent responsible for creating final investment recommendations. Synthesize all previous agent outputs:

PLANNING: ${planningResult.substring(0, 300)}...
RESEARCH: ${researchResult.substring(0, 300)}...
ANALYSIS: ${analysisResult.substring(0, 300)}...
COMPLIANCE: ${complianceResult.substring(0, 300)}...

Generate exactly ${userPreferences.maxIdeas} diverse investment ideas that:
- Match risk tolerance: ${userPreferences.riskTolerance}
- Fit investment horizon: ${userPreferences.investmentHorizon}
- Focus on sectors: ${userPreferences.sectors.join(', ')}
- Pass compliance requirements
- Include quantitative analysis

Format as JSON array:
[
  {
    "title": "Investment Title",
    "description": "Detailed description (2-3 sentences)",
    "riskLevel": "conservative|moderate|aggressive",
    "expectedReturn": "X-Y% annually",
    "timeHorizon": "short-term|medium-term|long-term",
    "reasoning": "Multi-agent analysis reasoning",
    "confidence": 0.85,
    "sectors": ["sector1", "sector2"],
    "complianceNotes": "Any compliance considerations"
  }
]`;

    const synthesisResult = await callBedrockModel(bedrockClient, 'us.anthropic.claude-3-7-sonnet-20250219-v1:0', synthesisPrompt);
    modelsUsed.push('Claude Sonnet 3.7 (Synthesis)');
    
    processingSteps.push({
      step: 'synthesis',
      agent: 'Synthesis Agent',
      model: 'Claude Sonnet 3.7',
      duration: Date.now() - synthesisStepStart,
      status: 'completed'
    });

    // Parse the final investment ideas
    let ideas = [];
    try {
      const jsonMatch = synthesisResult.match(/\[[\s\S]*\]/);
      if (jsonMatch) {
        const parsedIdeas = JSON.parse(jsonMatch[0]);
        ideas = parsedIdeas.map((idea: any, index: number) => ({
          id: `multi-agent-${index + 1}`,
          title: idea.title || `Multi-Agent Investment Idea ${index + 1}`,
          description: idea.description || 'Generated through multi-agent AI orchestration',
          riskLevel: idea.riskLevel || userPreferences.riskTolerance,
          expectedReturn: idea.expectedReturn || '6-10% annually',
          timeHorizon: idea.timeHorizon || userPreferences.investmentHorizon,
          confidence: idea.confidence || 0.85,
          reasoning: idea.reasoning || 'Generated through comprehensive multi-agent analysis',
          sectors: idea.sectors || userPreferences.sectors,
          complianceNotes: idea.complianceNotes || 'Reviewed by compliance agent',
          mode: 'multi-agent',
          multiAgent: true,
          agentsUsed: ['Planning', 'Research', 'Analysis', 'Compliance', 'Synthesis']
        }));
      }
    } catch (parseError) {
      console.log('Could not parse JSON from synthesis, creating fallback ideas:', parseError);
      ideas = createFallbackMultiAgentIdeas(userPreferences, synthesisResult);
    }

    const totalProcessingTime = Date.now() - startTime;

    return {
      ideas,
      metadata: {
        totalIdeasGenerated: ideas.length,
        processingSteps,
        userPreferences,
        multiAgentWorkflow: true,
        agentsUsed: ['Planning Agent', 'Research Agent', 'Analysis Agent', 'Compliance Agent', 'Synthesis Agent']
      },
      processingMetrics: {
        totalProcessingTime,
        stepCount: processingSteps.length,
        averageStepTime: totalProcessingTime / processingSteps.length,
        modelsUsed
      },
      modelsUsed
    };

  } catch (error) {
    console.error('Error in multi-agent orchestration:', error);
    
    // Return fallback with error info
    return {
      ideas: createFallbackMultiAgentIdeas(userPreferences, 'Multi-agent orchestration encountered an error'),
      metadata: {
        totalIdeasGenerated: 1,
        processingSteps,
        userPreferences,
        multiAgentWorkflow: true,
        error: error instanceof Error ? error.message : 'Unknown error'
      },
      processingMetrics: {
        totalProcessingTime: Date.now() - startTime,
        stepCount: processingSteps.length,
        modelsUsed
      },
      modelsUsed
    };
  }
}

/**
 * Call a Bedrock model with error handling
 */
async function callBedrockModel(client: any, modelId: string, prompt: string): Promise<string> {
  try {
    let requestBody;
    
    // Different API formats for different models
    if (modelId.includes('nova')) {
      // Amazon Nova Pro format
      requestBody = {
        messages: [
          {
            role: 'user',
            content: [
              {
                text: prompt
              }
            ]
          }
        ],
        inferenceConfig: {
          maxTokens: 2000,
          temperature: 0.7
        }
      };
    } else {
      // Claude format
      requestBody = {
        anthropic_version: 'bedrock-2023-05-31',
        max_tokens: 2000,
        temperature: 0.7,
        messages: [
          {
            role: 'user',
            content: prompt
          }
        ]
      };
    }

    const request = {
      modelId,
      contentType: 'application/json',
      accept: 'application/json',
      body: JSON.stringify(requestBody)
    };

    const command = new (await import('@aws-sdk/client-bedrock-runtime')).InvokeModelCommand(request);
    const response = await client.send(command);
    const responseBody = JSON.parse(new TextDecoder().decode(response.body));
    
    // Different response formats for different models
    if (modelId.includes('nova')) {
      // Amazon Nova Pro response format
      return responseBody.output?.message?.content?.[0]?.text || responseBody.output?.text || 'Nova Pro response parsing error';
    } else {
      // Claude response format
      return responseBody.content[0].text;
    }
  } catch (error) {
    console.error(`Error calling model ${modelId}:`, error);
    return `Error calling ${modelId}: ${error instanceof Error ? error.message : 'Unknown error'}`;
  }
}

/**
 * Create fallback investment ideas when multi-agent processing fails
 */
function createFallbackMultiAgentIdeas(userPreferences: any, errorInfo: string): any[] {
  return [{
    id: 'multi-agent-fallback-1',
    title: 'Multi-Agent Generated Investment Portfolio',
    description: `Investment idea generated through multi-agent AI orchestration system tailored for ${userPreferences.riskTolerance} risk tolerance and ${userPreferences.investmentHorizon} investment horizon.`,
    riskLevel: userPreferences.riskTolerance,
    expectedReturn: '7-11% annually',
    timeHorizon: userPreferences.investmentHorizon,
    confidence: 0.75,
    reasoning: 'Generated through multi-agent AI system with planning, research, analysis, compliance, and synthesis agents',
    sectors: userPreferences.sectors,
    complianceNotes: 'Reviewed by AI compliance agent',
    mode: 'multi-agent-fallback',
    multiAgent: true,
    agentsUsed: ['Planning', 'Research', 'Analysis', 'Compliance', 'Synthesis'],
    note: 'Fallback response due to processing complexity'
  }];
}

/**
 * Process async job in background (fire and forget)
 * In production, this would be handled by SQS + separate Lambda worker
 */
function processAsyncJob(jobId: string, userPreferences: any): Promise<void> {
  // Return immediately - don't block the API response
  return Promise.resolve().then(() => {
    console.log(`Background processing queued for job ${jobId}`);
    
    // In production, this would:
    // 1. Send message to SQS queue
    // 2. SQS would trigger a separate Lambda worker
    // 3. Worker would run the multi-agent orchestration
    // 4. Results would be stored in DynamoDB
    // 5. WebSocket notifications would be sent
    
    // For demo purposes, just log that it's queued
    console.log(`Job ${jobId} queued for background processing with preferences:`, userPreferences);
  });
}